
#Область ИнтерфейсАвтоматическихТестов

&НаКлиенте
Перем ЮнитТест;

&НаКлиенте
Функция ПолучитьСписокТестов(ЮнитТестирование) Экспорт
	
	ЮнитТест = ЮнитТестирование;
	
	СписокТестов = Новый Массив;	
	
	ПараметрыТеста = Новый Структура("ИмяТеста, Транзакция, Параметр", "Тест_Заглушка");
	СписокТестов.Добавить(ПараметрыТеста);
	
	Возврат СписокТестов;
	
КонецФункции

&НаКлиенте
Функция Тест_Заглушка(Параметр) Экспорт
	ЮнитТест.ПроверитьИстину(Истина,);
КонецФункции // Тест_Заглушка()


#КонецОбласти


&НаКлиенте
Процедура ПривязатьНомер(Команда)	
	Партнер = ОткрытьФормуМодально("Справочник.Партнеры.ФормаВыбора");
	Если ТипЗнч(Партнер) = Тип("СправочникСсылка.Партнеры") Тогда
		ПривязатьНомерНаСервере(Партнер);
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура Зарегистрировать(Команда)
	
	Отказ = Ложь;
	
	Если НЕ ПустаяСтрока(КлиентEmail) Тогда
		Если ПроверитьЗаполнениеПочтовогоАдреса(КлиентEmail) Тогда
			ВывестиСообщениеПользователю(НСтр("ru = 'Неверный формат адреса электронной почты партнера'"), "КлиентEmail");
			Отказ = Истина;	
		КонецЕсли;
	КонецЕсли;
	
	Если ПустаяСтрока(КлиентФамилия) Тогда
		ВывестиСообщениеПользователю(НСтр("ru = 'Фамилия клиента не заполнена'"), "КлиентФамилия");
		Отказ = Истина;	
	КонецЕсли;
	
	Если ПустаяСтрока(КлиентИмя) Тогда
		ВывестиСообщениеПользователю(НСтр("ru = 'Имя клиента не заполнено'"), "КлиентИмя");
		Отказ = Истина;
	КонецЕсли;
	
	Если ПустаяСтрока(КлиентОтчество) Тогда
		ВывестиСообщениеПользователю(НСтр("ru = 'Отчество клиента не заполнено'"), "КлиентОтчество");
		Отказ = Истина;
	КонецЕсли;
	
	Если КлиентГруппаДоступа.Пустая() Тогда
		ВывестиСообщениеПользователю(НСтр("ru = 'Группа доступа клиента не заполнена'"), "КлиентГруппаДоступа");
		Отказ = Истина;
	КонецЕсли;
	
	Если КлиентБизнесРегион.Пустая() Тогда
		ВывестиСообщениеПользователю(НСтр("ru = 'Бизнес регион клиента не заполнен'"), "КлиентБизнесРегион");
		Отказ = Истина;
	КонецЕсли;
	
	Если КлиентСегмент.Пустая() Тогда
		ВывестиСообщениеПользователю(НСтр("ru = 'Сегмент клиента не заполнен'"), "КлиентСегмент");
		Отказ = Истина;
	КонецЕсли;
	
	
	Если Не Отказ Тогда
		ЗарегистрироватьНаСервере();
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ЗакрытьФорму(Команда)
	Закрыть(Ссылка);
КонецПроцедуры


&НаКлиенте
Процедура ЛогинОкончаниеВводаТекста(Элемент, Текст, ДанныеВыбора, СтандартнаяОбработка)
	
	ОбновитьДоступностьКнопок(СформироватьСтруктуруДоступности());
	
	Если СтрДлина(СтрЗаменить(Текст, " ", "")) < 10 Тогда
		ВывестиСообщениеПользователю(НСтр("ru = 'Длина номера не верна!'"), "Логин");
		ОбновитьПанельИнформация("Введите номер мобильного телефона.");
	ИначеЕсли  Лев(Текст, 1) <> "0" Тогда
		
		Текст = "";
		
		ВывестиСообщениеПользователю(НСтр("ru = 'Номер телефона должен начинаться с 0!'"), "Логин");
		ОбновитьПанельИнформация("Введите номер мобильного телефона.");
	Иначе
		ОбновитьПанельИнформация("", Текст);
	КонецЕсли;
	
	Логин = Текст;
	
КонецПроцедуры

&НаКлиенте
Процедура КаналПервичногоИнтересаПриИзменении(Элемент)
	
	Если НЕ ЗначениеЗаполнено(КаналПервичногоИнтереса) Тогда
		ИсточникПервичногоИнтереса = Неопределено;
	КонецЕсли;
	
	Элементы.ИсточникПервичногоИнтереса.ТолькоПросмотр = НЕ ЗначениеЗаполнено(КаналПервичногоИнтереса);
	
КонецПроцедуры



Процедура ВывестиСообщениеПользователю(ТекстСообщения, Поле="", ОчищатьСообщения = Ложь)
#Если ТонкийКлиент Тогда	
	Если ОчищатьСообщения Тогда
		ОчиститьСообщения();
	КонецЕсли;
#КонецЕсли	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения, , Поле);
	
КонецПроцедуры








Процедура ОбновитьДоступностьКнопок(СтруктураДоступности)
	
	Для Каждого ЭлементИзСтруктуры Из СтруктураДоступности Цикл
		Элементы[ЭлементИзСтруктуры.Ключ].Доступность = ЭлементИзСтруктуры.Значение;
	КонецЦикла;
	
КонецПроцедуры

Функция СформироватьСтруктуруДоступности(ПривязатьНомер = Ложь, Зарегистрировать = Ложь)
	
	СтруктураДоступности = Новый Структура;
	СтруктураДоступности.Вставить("ПривязатьНомер",  	ПривязатьНомер);
	СтруктураДоступности.Вставить("Зарегистрировать",	Зарегистрировать);
	Возврат СтруктураДоступности;
	
КонецФункции

Процедура ОбновитьПанельИнформация(СтрокаИнформации, Номер = "")
	
	Информация = СтрокаИнформации;
	Если НЕ ПустаяСтрока(Номер) Тогда
		ОбновитьИнформациюПоНомеру(Номер);	
	КонецЕсли;
	
КонецПроцедуры









&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	Организация = Параметры.Организация;	
	ОбновитьПанельИнформация("Введите номер мобильного телефона."); 
	
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	ПриОткрытииЗаполнитьБазовыеЗначения();
КонецПроцедуры

&НаСервере
Процедура ПриОткрытииЗаполнитьБазовыеЗначения()
	
	Запрос = Новый Запрос("ВЫБРАТЬ Сегмент, БизнесРегион, ГруппаДоступа  ИЗ РегистрСведений.Лояльность_Настройки ГДЕ Организация = &Организация");
	Запрос.УстановитьПараметр("Организация", Организация);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		КлиентСегмент 		= Выборка.Сегмент;
		КлиентБизнесРегион 	= Выборка.БизнесРегион;
		КлиентГруппаДоступа = Выборка.ГруппаДоступа;
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Функция РезультатЗапросаИнфоИзРгЛояльностьНомераТелефонов(Номер = Неопределено, Партнер = Неопределено)
	
	Если Номер <> Неопределено И Партнер <> Неопределено Тогда
		ПараметрыОграничения = "ГДЕ НомерТелефона = &Номер И Партнер = &Партнер";	
	ИначеЕсли Номер <> Неопределено Тогда
		ПараметрыОграничения = "ГДЕ НомерТелефона = &Номер";
	ИначеЕсли Партнер <> Неопределено ТОгда
		ПараметрыОграничения = "ГДЕ Партнер = &Партнер";
	Иначе
		ПараметрыОграничения = "";
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ * ИЗ РегистрСведений.Лояльность_НомераТелефонов " + ПараметрыОграничения;
	Запрос.УстановитьПараметр("Номер", 		Номер);
	Запрос.УстановитьПараметр("Партнер", 	Партнер);	
	
	Возврат Запрос.Выполнить();
	
КонецФункции

&НаСервере
Процедура ОбновитьИнформациюПоНомеру(Номер)
			
	Выборка = РеквизитФормыВЗначение("Объект").GetLibrary("LoyaltyLibrary").ВыборкаИнфоИзРгЛояльностьНомераТелефонов(Номер);	
	Если Выборка.Следующий() Тогда
		ОбновитьПанельИнформация("Клиент - " + Выборка.Партнер);
		ОбновитьДоступностьКнопок(СформироватьСтруктуруДоступности());
	Иначе
		ОбновитьПанельИнформация("Номер - не зарегистрирован в базе");
		ОбновитьДоступностьКнопок(СформироватьСтруктуруДоступности(Истина, Истина));
	КонецЕсли;
	
КонецПроцедуры





&НаСервере
Функция ПолучитьПартнераПоНомеруНаСервере()
	
	ЗапросПроверкаУникальности = Новый Запрос("ВЫБРАТЬ Партнер ИЗ РегистрСведений.Лояльность_НомераТелефонов ГДЕ НомерТелефона = &Номер");
	ЗапросПроверкаУникальности.УстановитьПараметр("Номер", Логин);			
	Выборка = ЗапросПроверкаУникальности.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.Партнер;
	Иначе
		Возврат Неопределено;	
	КонецЕсли;
	
КонецФункции

&НаСервере
Процедура ПривязатьНомерНаСервере(Партнер)
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если НЕ РезультатЗапросаИнфоИзРгЛояльностьНомераТелефонов(Логин).Пустой() Тогда
		ВывестиСообщениеПользователю(НСтр("ru = 'Номер уже привязан к партнеру!'"), "Логин");
		Возврат;
	КонецЕсли;
	
	Выборка = РеквизитФормыВЗначение("Объект").GetLibrary("LoyaltyLibrary").ВыборкаИнфоИзРгЛояльностьНомераТелефонов(, Партнер);
	
	НаборЗаписей = РегистрыСведений.Лояльность_НомераТелефонов.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Партнер.Установить(Партнер);
	НаборЗаписей.Отбор.НомерТелефона.Установить(Логин);
	
	Запись = НаборЗаписей.Добавить();
	Запись.Партнер 			= Партнер;
	Запись.НомерТелефона	= Логин;
	Запись.ДатаРегистрации	= ТекущаяДата();
	Запись.Основной = НЕ Выборка.Следующий();
	НаборЗаписей.Записать();
	
	ОбновитьДоступностьКнопок(СформироватьСтруктуруДоступности());
	ОбновитьПанельИнформация("", Логин);
	
	Ссылка = Партнер;
	
КонецПроцедуры




&НаСервере
Процедура ЗарегистрироватьНаСервере()
	
	Если НЕ РезультатЗапросаИнфоИзРгЛояльностьНомераТелефонов(Логин).Пустой() Тогда
		ВывестиСообщениеПользователю(НСтр("ru = 'Номер уже привязан к партнеру!'"), "Логин");
		Возврат;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	
	
	СоответствиеПолей = Новый СписокЗначений;
	СоответствиеПолей.Добавить("+38", 			"КодСтраны");
	СоответствиеПолей.Добавить(Лев(Логин, 3),  	"КодГорода");
	СоответствиеПолей.Добавить(Прав(Логин, 7), 	"НомерТелефона");
	СоответствиеПолей.Добавить("", 				"Добавочный");
	СоответствиеПолей.Добавить("", 				"Комментарий");
	
	
	
	//Партнер
	ОбъектПартнер = Справочники.Партнеры.СоздатьЭлемент();
	ОбъектПартнер.Наименование		= ПолучитьФИО_ОднойСтрокой(КлиентФамилия, КлиентИмя, КлиентОтчество);
	ОбъектПартнер.БизнесРегион		= КлиентБизнесРегион;
	ОбъектПартнер.ГруппаДоступа		= КлиентГруппаДоступа;
	ОбъектПартнер.ДатаРегистрации	= ТекущаяДата();
	ОбъектПартнер.Клиент			= Истина;
	ОбъектПартнер.ОсновнойМенеджер	= ПараметрыСеанса.ТекущийПользователь;	
	
	НоваяСтрокаКИ = ОбъектПартнер.КонтактнаяИнформация.Добавить();
	НоваяСтрокаКИ.Тип 				= Перечисления.ТипыКонтактнойИнформации.Телефон;
	НоваяСтрокаКИ.Вид				= Справочники.ВидыКонтактнойИнформации.ТелефонПартнера;
	НоваяСтрокаКИ.Представление		= "+38 (" + Лев(Логин, 3) + ")" + Прав(Логин, 7);
	НоваяСтрокаКИ.ЗначенияПолей		= ПреобразоватьСписокПолейВСтроку(СоответствиеПолей);
	ЗаполнитьРеквизитыТабличнойЧастиДляТелефона(НоваяСтрокаКИ, СоответствиеПолей);
	
	Если Не ПустаяСтрока(КлиентEmail) Тогда
		НоваяСтрокаКИ 					= ОбъектПартнер.КонтактнаяИнформация.Добавить();
		НоваяСтрокаКИ.Тип				= Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты;
		НоваяСтрокаКИ.Вид 				= Справочники.ВидыКонтактнойИнформации.EmailПартнера;
		НоваяСтрокаКИ.Представление 	= КлиентEmail;
		НоваяСтрокаКИ.АдресЭП 			= КлиентEmail;
		Поз = Найти(КлиентEmail, "@");
		Если Поз <> 0 Тогда
			НоваяСтрокаКИ.ДоменноеИмяСервера = Сред(КлиентEmail, Поз+1);
		КонецЕсли;
	КонецЕсли;
	
	ОбъектПартнер.Записать();
	
	
	
	//зафиксировать первичный интерес
	Если ПолучитьФункциональнуюОпцию("ФиксироватьПервичныйИнтерес") И ЗначениеЗаполнено(ИсточникПервичногоИнтереса) Тогда

		УстановитьПривилегированныйРежим(Истина);
		Запись = РегистрыСведений.ИсточникиПервичногоИнтереса.СоздатьМенеджерЗаписи();
		Запись.Партнер						= ОбъектПартнер.Ссылка;
		Запись.КаналПервичногоИнтереса		= КаналПервичногоИнтереса;
		Запись.ИсточникПервичногоИнтереса	= ИсточникПервичногоИнтереса;
		Запись.Записать();
		УстановитьПривилегированныйРежим(Ложь);

	КонецЕсли;
	
	
	
	//занести в сегмент
	ДобавитьВСегментПартнера(ОбъектПартнер.Ссылка);
	
	
	
	//Контрагент
	ОбъектКонтрагент = Справочники.Контрагенты.СоздатьЭлемент();
	ОбъектКонтрагент.Наименование		= ПолучитьФИО_ОднойСтрокой(КлиентФамилия, КлиентИмя, КлиентОтчество);
	ОбъектКонтрагент.ЮрФизЛицо			= Перечисления.ЮрФизЛицо.ФизЛицо;
	ОбъектКонтрагент.Партнер			= ОбъектПартнер.Ссылка;
	ОбъектКонтрагент.НаименованиеПолное = ПолучитьФИО_ОднойСтрокой(КлиентФамилия, КлиентИмя, КлиентОтчество);			
	ОбъектКонтрагент.Записать();

		
	
	ЗафиксироватьТранзакцию();
	
	ПривязатьНомерНаСервере(ОбъектПартнер.Ссылка);
	
КонецПроцедуры

&НаСервере
Процедура ДобавитьВСегментПартнера(Партнер)
	
	Если НЕ КлиентСегмент.Пустая() Тогда
		УстановитьПривилегированныйРежим(Истина);
			Запись = РегистрыСведений.ПартнерыСегмента.СоздатьМенеджерЗаписи();
			Запись.Партнер		= Партнер;
			Запись.Сегмент		= КлиентСегмент;
			Запись.Записать();
		УстановитьПривилегированныйРежим(Ложь);
	КонецЕсли;

КонецПроцедуры

// Формирует строку из Фамилии, Имени и Отчества
//
// Параметры
//  Фамилия		- Строка
//  Имя			- Строка
//  Отчество	- Строка
//
// Возвращаемое значение:
//   Строка   - сформированная строка
//
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьФИО_ОднойСтрокой(Фамилия,Имя,Отчество)
	
	Возврат СокрЛП(СокрЛП(Фамилия) + " " + СокрЛП(Имя) + " " + СокрЛП(Отчество));
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПреобразоватьСписокПолейВСтроку(СоответствиеПолей)
	
	Результат = "";
	Для Каждого Элемент Из СоответствиеПолей Цикл
		
		Значение = Элемент.Значение;
		Если ПустаяСтрока(Значение) Тогда
			Продолжить;
		КонецЕсли;
		
		Результат = Результат + ?(Результат = "", "", Символы.ПС) + 
			Элемент.Представление + "=" + СтрЗаменить(Значение, Символы.ПС, Символы.ПС + Символы.Таб);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Процедура ЗаполнитьРеквизитыТабличнойЧастиДляТелефона(СтрокаТабличнойЧасти, ЗначенияПолей)
	
	КодСтраны = "";
	КодГорода = "";
	НомерТелефона = "";
	
	Для Каждого ЗначениеПоля Из ЗначенияПолей Цикл
		Если ВРег(ЗначениеПоля.Представление) = "КОДСТРАНЫ" Тогда
			КодСтраны = ЗначениеПоля.Значение;
		ИначеЕсли ВРег(ЗначениеПоля.Представление) = "КОДГОРОДА" Тогда
			КодГорода = ЗначениеПоля.Значение;
		ИначеЕсли ВРег(ЗначениеПоля.Представление) = "НОМЕРТЕЛЕФОНА" Тогда
			НомерТелефона = ЗначениеПоля.Значение;
		КонецЕсли;
	КонецЦикла;
	
	Если Лев(КодСтраны, 1) = "+" Тогда
		КодСтраны = Сред(КодСтраны, 2);
	КонецЕсли;
	
	Поз = Найти(НомерТелефона, ",");
	Если Поз <> 0 Тогда
		НомерТелефона = Лев(НомерТелефона, Поз-1);
	КонецЕсли;
	
	Поз = Найти(НомерТелефона, Символы.ПС);
	Если Поз <> 0 Тогда
		НомерТелефона = Лев(НомерТелефона, Поз-1);
	КонецЕсли;
	
	СтрокаТабличнойЧасти.НомерТелефонаБезКодов = УбратьРазделителиВНомерТелефона(НомерТелефона);
	СтрокаТабличнойЧасти.НомерТелефона         = УбратьРазделителиВНомерТелефона(КодСтраны + КодГорода + НомерТелефона);
	
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция УбратьРазделителиВНомерТелефона(Знач СтрНомер)
	
	Поз = Найти(СтрНомер, ",");
	Если Поз <> 0 Тогда
		СтрНомер = Лев(СтрНомер, Поз-1);
	КонецЕсли;
	
	СтрНомер = СтрЗаменить(СтрНомер, "-", "");
	СтрНомер = СтрЗаменить(СтрНомер, " ", "");
	СтрНомер = СтрЗаменить(СтрНомер, "+", "");

	Возврат СтрНомер;

КонецФункции







// Проверяет строку с адресом электронной почты на корректность введенных данных
//
// Параметры
//  ПроверяемыйАдрес  - Строка - содержит строку с адресом электронной почты,
//                 		которую необходимо проверить.
// Возвращаемое значение:
//   Булево   		 - Ложь, если проверка закончилась успешно, Истина в обратном случае.
//
&НаСервереБезКонтекста
Функция ПроверитьЗаполнениеПочтовогоАдреса(ПроверяемыйАдрес) Экспорт
	
	Отказ = Ложь;
	АдресДляПроверки = ПроверяемыйАдрес;
	
	Попытка
		Результат =  РазобратьСтрокуСПочтовымиАдресами(АдресДляПроверки);	 
	Исключение 		
		Отказ = Истина;
	КонецПопытки;
	
	Если НЕ Отказ Тогда
		Если Результат.Количество() = 0 Тогда
			Отказ =  Истина;
		Иначе	
			АдресДляПроверки = Результат[0].Адрес;
			Если СтрЧислоВхождений(АдресДляПроверки,"@") <> 1 Тогда 
				Отказ = Истина;
			Иначе
				ДоменныйАдрес = Прав(АдресДляПроверки, СтрДлина(АдресДляПроверки) - Найти(АдресДляПроверки,"@"));
				Если СтрДлина(ДоменныйАдрес) > 0 Тогда
					Если СтрЧислоВхождений(ДоменныйАдрес,".") < 1 ИЛИ Лев(ДоменныйАдрес,1) = "." ИЛИ Прав(ДоменныйАдрес,1) = "." Тогда
						Отказ = Истина;
					КонецЕсли;
				Иначе
					Отказ = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;	
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеПочтовогоАдреса()

// Функция проверяет что введенная строка с e-mail адресами введена правильно
//
// Формат строки:
// Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовый_сервер[>], Строка = Z[<разделитель*>Z]..
// 
//   прим.: разделитель* - имеется в виду любой разделитель адресов
//
// Параметры:
// СтрокаАдресов - строка - правильная строка с почтовыми адресами
//
// Возвращаемое значение:
// Структура
// ключ Статус - булево - успех или неуспех преобразования
// в случае успеха содержит ключ Значение:
//           Массив структур, где
//                  Адрес- e-mail получателя
//                  Представление   - имя получателя
// в случае неуспеха содержит ключ СообщениеОбОшибке - строка
//
//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
//         может быть незаполнено. Может использоваться различными
//         подсистемами для собственного сопоставления имени пользователя
//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
//         отправкой проверить, что поле почтового адреса заполнено.
//
&НаСервереБезКонтекста
Функция РазобратьСтрокуСПочтовымиАдресами(знач СтрокаАдресов) Экспорт
	
	Результат = Новый Массив;
	
	НедопустимыеСимволы = "!#$%^&*()+`~|\/=";
	СимволыРазделители = ";,";
	
	Индекс = 1;               // номер обрабатываемого символа
	Накопитель = "";          // накопитель символов, после анализа перемещается либо в полное имя
	                          // либо в почтовый адрес
	ПолноеИмяАдресата = "";   // переменная, накапливающая имя адресата
	ПочтовыйАдрес = "";       // переменная, накапливающая e-mail адрес
	// 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
	// 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
	// 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы
	СтадияРазбора = 1; 
	
	СообщениеНедопустимыеСимволы = НСтр("ru = 'Недопустимые символы в почтовом адресе.'");
	СообщениеНеверныйФорматПочтовогоАдреса = НСтр("ru = 'Неверный формат почтового адреса.'");
	
	Пока Индекс <= СтрДлина(СтрокаАдресов) Цикл
		
		Символ = Сред(СтрокаАдресов, Индекс, 1);
		
		Если      Символ = " " Тогда
			Индекс = ? ((ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1) > Индекс,
			             ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1,
			             Индекс);
			Если      СтадияРазбора = 1 Тогда
				ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + " ";
			ИначеЕсли СтадияРазбора = 2 Тогда
				ПочтовыйАдрес = Накопитель;
				СтадияРазбора = 3;
			КонецЕсли;
			Накопитель = "";
		ИначеЕсли Символ = "@" Тогда
			Если      СтадияРазбора = 1 Тогда
				СтадияРазбора = 2;
				
				Для ИндексПоискаНС = 1 По СтрДлина(Накопитель) Цикл
					Если Найти(НедопустимыеСимволы, Сред(Накопитель, ИндексПоискаНС, 1)) > 0 Тогда
						ВызватьИсключение СообщениеНедопустимыеСимволы;
					КонецЕсли;
				КонецЦикла;
				
				Накопитель = Накопитель + Символ;
			ИначеЕсли СтадияРазбора = 2 Тогда
				ВызватьИсключение СообщениеНеверныйФорматПочтовогоАдреса;
			ИначеЕсли СтадияРазбора = 3 Тогда
				ВызватьИсключение СообщениеНеверныйФорматПочтовогоАдреса;
			КонецЕсли;
		ИначеЕсли Найти(СимволыРазделители, Символ) > 0 Тогда
			
			Если      СтадияРазбора = 1 Тогда
				ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
			ИначеЕсли СтадияРазбора = 2 Тогда
				ПочтовыйАдрес = Накопитель;
			КонецЕсли;
			
			СтадияРазбора = 1;
			
			Если НЕ (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
				Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
			КонецЕсли;
			
			ПочтовыйАдрес = "";
			ПолноеИмяАдресата = "";
			Накопитель = "";
		Иначе
			Если СтадияРазбора = 2 ИЛИ СтадияРазбора = 3 Тогда
				Если Найти(НедопустимыеСимволы, Символ) > 0 Тогда
					ВызватьИсключение СообщениеНедопустимыеСимволы;
				КонецЕсли;
			КонецЕсли;
			
			Накопитель = Накопитель + Символ;
		КонецЕсли;
		
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Если      СтадияРазбора = 1 Тогда
		ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
	ИначеЕсли СтадияРазбора = 2 Тогда
		ПочтовыйАдрес = Накопитель;
	КонецЕсли;

	Если НЕ (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
		Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверяет, что почтовый адрес не содержит символов обрамления
// если символы обрамления вставлены правильно убирает их
// Параметры:
//  ПолноеИмяАдресата - строка - имя получателя
//  ПочтовыйАдрес     - строка - email адрес
// Возвращаемое значение:
//  Структура:
//   Ключ статус - булево - успех или неуспех операции
//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
//                          адреса: ключи - Адрес, Представление (строки)
&НаСервереБезКонтекста
Функция ПроверитьИПодготовитьПочтовыйАдрес(знач ПолноеИмяАдресата, знач ПочтовыйАдрес)
	
	НедопустимыйСимволВИмениАдресата = НСтр("ru = 'Недопустимый символ в имени адресата.'");
	НедопустимыйСимволВПочтовомАдресе = НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
	СимволыОбрамления = "<>[]";
	
	ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	
	Если Лев(ПолноеИмяАдресата, 1) = "<" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = ">" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	ИначеЕсли Лев(ПолноеИмяАдресата, 1) = "[" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = "]" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	КонецЕсли;
	
	Если Лев(ПочтовыйАдрес, 1) = "<" Тогда
		Если Прав(ПочтовыйАдрес, 1) = ">" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	ИначеЕсли Лев(ПочтовыйАдрес, 1) = "[" Тогда
		Если Прав(ПочтовыйАдрес, 1) = "]" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		Если Найти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
		 ИЛИ Найти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Адрес, Представление", ПочтовыйАдрес,ПолноеИмяАдресата);
	
КонецФункции

// Сдвигает маркер позиции пока встречается символ Символ
// возвращает номер позиции в строке, на которое установился маркер
//
&НаСервереБезКонтекста
Функция ПропуститьПробелы(знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол)
	
	Результат = ТекущийИндекс;
	
	// убираем лишние пробелы если они есть
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	Возврат ТекущийИндекс;
	
КонецФункции







